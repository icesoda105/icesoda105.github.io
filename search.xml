<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Gateway创建&amp;测试API网关</title>
      <link href="/icesoda105.github.io/2023/01/13/Gateway%E5%88%9B%E5%BB%BA-%E6%B5%8B%E8%AF%95API%E7%BD%91%E5%85%B3/"/>
      <url>/icesoda105.github.io/2023/01/13/Gateway%E5%88%9B%E5%BB%BA-%E6%B5%8B%E8%AF%95API%E7%BD%91%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<ul><li><p>创建网关 依赖common   并修改各依赖版本</p><p><img src="https://icesoda-picgo.oss-cn-beijing.aliyuncs.com/imgtest/202301131026248.png" alt="image-20230113102617630"></p></li><li><p>开启服务的注册发现</p><p><img src="https://icesoda-picgo.oss-cn-beijing.aliyuncs.com/imgtest/202301131029757.png" alt="image-20230113102930535"></p></li><li><p>配置nacos的注册中心地址</p><p><img src="https://icesoda-picgo.oss-cn-beijing.aliyuncs.com/imgtest/202301131030284.png" alt="image-20230113103025197"></p></li><li><p>命名空间</p><p><img src="https://icesoda-picgo.oss-cn-beijing.aliyuncs.com/imgtest/202301131032785.png" alt="image-20230113103228750"></p><p><img src="https://icesoda-picgo.oss-cn-beijing.aliyuncs.com/imgtest/202301131034415.png" alt="image-20230113103450503"></p></li><li><p>排除和数据源有关的配置</p><p><img src="https://icesoda-picgo.oss-cn-beijing.aliyuncs.com/imgtest/202301131037766.png" alt="image-20230113103734234"></p><p><code>@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class&#125;)</code></p><p>网关还没有用到数据库，但是common里有这个依赖，所以要排除</p></li><li><p>配置网关所使用的的端口</p><p><code>server.port=88</code></p><p><img src="https://icesoda-picgo.oss-cn-beijing.aliyuncs.com/imgtest/202301131039710.png" alt="image-20230113103930547"></p></li><li><p>配置网关路由规则</p><p><img src="https://icesoda-picgo.oss-cn-beijing.aliyuncs.com/imgtest/202301131043086.png" alt="image-20230113104313900"></p><p><code>http://localhost:88/hello?url=weibo</code></p><p><img src="https://icesoda-picgo.oss-cn-beijing.aliyuncs.com/imgtest/202301131051563.png" alt="image-20230113105133649"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> icesodaMall </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gateway </tag>
            
            <tag> SpingCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gateway网关核心概念&amp;原理</title>
      <link href="/icesoda105.github.io/2023/01/13/Gateway%E7%BD%91%E5%85%B3%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5-%E5%8E%9F%E7%90%86/"/>
      <url>/icesoda105.github.io/2023/01/13/Gateway%E7%BD%91%E5%85%B3%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5-%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><img src="https://icesoda-picgo.oss-cn-beijing.aliyuncs.com/imgtest/202301130959271.png" alt="image-20230113095945682"></p>]]></content>
      
      
      <categories>
          
          <category> icesodaMall </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gateway </tag>
            
            <tag> SpingCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nacos配置中心</title>
      <link href="/icesoda105.github.io/2023/01/12/Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"/>
      <url>/icesoda105.github.io/2023/01/12/Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><blockquote><p>   如何使用nacos作为配置中心 统一管理配置</p><ol><li><p>引入依赖<br><code>&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt;</code></p></li><li><p>创建一个 bootstrap.properties<br><code>spring.application.name=icesodamall-coupon spring.cloud.nacos.config.server-addr=127.0.0.1:8848</code></p></li><li><p>需要给配置中心默认添加一个叫 数据集(Data Id)</p><p>   默认规则当前应用名</p><p>   <code>.properties(icesodamall-coupon.properties)</code></p></li><li><p>给应用名.properties添加任何配置</p></li><li><p>动态获取配置</p></li></ol><p>@RefreshScope: 动态获取并刷新配置<br>@Value(“${配置项的名}”)： 获取到配置。<br>如果配置中心和当前应用的配置文件照片那个都配置了相同的项 优先使用配置中心的配置</p></blockquote><ul><li><p>在公共项目中导入注册发现的依赖</p><p><img src="https://icesoda-picgo.oss-cn-beijing.aliyuncs.com/imgtest/202301121459478.png" alt="image-20230112145924335"></p></li><li><p>创建文件，bootstrap.properties 会优先于 application.properties</p><p><img src="https://icesoda-picgo.oss-cn-beijing.aliyuncs.com/imgtest/202301121508354.png" alt="image-20230112150110809"></p><p><img src="https://icesoda-picgo.oss-cn-beijing.aliyuncs.com/imgtest/202301121509098.png" alt="image-20230112150536716"></p></li><li><p>测试</p><p><img src="https://icesoda-picgo.oss-cn-beijing.aliyuncs.com/imgtest/202301121508921.png" alt="image-20230112150707186"></p></li></ul><ol><li>添加配置文件信息<br> <img src="https://icesoda-picgo.oss-cn-beijing.aliyuncs.com/imgtest/202301121542548.png" alt="image-20230112150811664"></li></ol><p>  <img src="https://icesoda-picgo.oss-cn-beijing.aliyuncs.com/imgtest/202301121542563.png" alt="image-20230112154234380"></p><ol start="2"><li>结果：</li></ol><p><img src="https://icesoda-picgo.oss-cn-beijing.aliyuncs.com/imgtest/202301121548636.png" alt="image-20230112151502640"></p><ol start="3"><li><p>若需修改，just:<br><img src="https://icesoda-picgo.oss-cn-beijing.aliyuncs.com/imgtest/202301121548019.png" alt="image-20230112154646252"></p><p><img src="https://icesoda-picgo.oss-cn-beijing.aliyuncs.com/imgtest/202301121548247.png" alt="image-20230112154842650"></p></li></ol><ul><li><p>改进：在配置中心该数据，all动态修改</p><ol><li><p>在配置中心中新建对应服务的配置</p><p><img src="https://icesoda-picgo.oss-cn-beijing.aliyuncs.com/imgtest/202301121558611.png" alt="image-20230112155816631"></p><p><img src="https://icesoda-picgo.oss-cn-beijing.aliyuncs.com/imgtest/202301121558596.png" alt="image-20230112155854948"></p></li><li><p>在controller中添加注解   @RefreshScope   刷新配置</p><p><img src="https://icesoda-picgo.oss-cn-beijing.aliyuncs.com/imgtest/202301121600906.png" alt="image-20230112160010953"></p></li><li><p>修改配置，无需重启动态更新</p><p><img src="https://icesoda-picgo.oss-cn-beijing.aliyuncs.com/imgtest/202301121601616.png" alt="image-20230112160142815"></p><p><img src="https://icesoda-picgo.oss-cn-beijing.aliyuncs.com/imgtest/202301121642317.png" alt="image-20230112164239641"></p></li></ol></li></ul><h2 id="命名空间与配置分组"><a href="#命名空间与配置分组" class="headerlink" title="命名空间与配置分组"></a>命名空间与配置分组</h2><blockquote><p>​命名空间： 配置隔离<br>默认：public(保留空间)：默认新增的所有配置都在public空间</p><p>开发 测试 生产 : 利用命名空间来做环境隔离<br>注意：在bootstrap.properties: 配置上 需要使用哪个命名空间下的配置<br><code>spring.cloud.nacos.config.namespace=</code></p><p>​每一个微服务之间互相隔离配置，每一个微服务都创建自己的命名空间，只加载自己命名空间下的所有配置</p><p>配置集： 所有的配置的集合</p><p>配置集ID 类似配置文件名<br>Data ID 类似配置文件名</p><p>配置分组<br>默认所有的配置集都属于：DEFAULT_GROUP：<br>1111, 618, 1212</p><p>​    每个微服务创建自己的命名空间。使用配置分组，区分环境，dev,test,prod</p></blockquote><ul><li><p>新建命名空间并添加对应配置</p><p><img src="https://icesoda-picgo.oss-cn-beijing.aliyuncs.com/imgtest/202301121718183.png" alt="image-20230112171835186"></p></li><li><p>在bootstrap中添加配置信息 指定生效的命名空间</p><p><img src="https://icesoda-picgo.oss-cn-beijing.aliyuncs.com/imgtest/202301121729165.png" alt="image-20230112172858120"></p></li><li><p>给每个微服务创建命名空间</p><p><img src="https://icesoda-picgo.oss-cn-beijing.aliyuncs.com/imgtest/202301121737992.png" alt="image-20230112173702480"></p><p>后续可以根据需求给各个微服务配置对应的命名空间</p></li><li><p>配置分组</p><p><img src="https://icesoda-picgo.oss-cn-beijing.aliyuncs.com/imgtest/202301121748931.png" alt="image-20230112174857458"></p><p><img src="https://icesoda-picgo.oss-cn-beijing.aliyuncs.com/imgtest/202301121749172.png" alt="image-20230112174915712"></p><p><img src="https://icesoda-picgo.oss-cn-beijing.aliyuncs.com/imgtest/202301121752031.png" alt="image-20230112175231900"></p></li></ul><h2 id="加载多配置集"><a href="#加载多配置集" class="headerlink" title="加载多配置集"></a>加载多配置集</h2><blockquote><p>同时加载多个配置集<br>1 微服务任何配置信息 任何配置文件都可以放在配置中心中<br>2 只需要在bootstrap.properties说明加载配置中心中配置哪些配置文件即可<br>3 <code>@Value @ConfigurationProperties ...</code><br>以前SpringBoot任何方式从配置文件中获取值 都能使用<br>配置中心有的优先使用配置中心中的</p></blockquote><ul><li><p>配置中心添加application.yml中的配置信息</p><p><img src="https://icesoda-picgo.oss-cn-beijing.aliyuncs.com/imgtest/202301130934424.png" alt="image-20230113093444459"></p><p><img src="https://icesoda-picgo.oss-cn-beijing.aliyuncs.com/imgtest/202301130936159.png" alt="image-20230113093612065"></p></li><li><p>让微服务启动时同时加载多个配置 以合成一个完成的配置</p><p><img src="https://icesoda-picgo.oss-cn-beijing.aliyuncs.com/imgtest/202301130941546.png" alt="image-20230113094101656"></p><p>动态刷新</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.cloud.nacos.config.extension-configs[<span class="number">0</span>].refresh=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>指定了命名空间、组名时，找到不对应的配置文件，就会读取本地配置里的配置文件。</strong></p><p><img src="https://icesoda-picgo.oss-cn-beijing.aliyuncs.com/imgtest/202301130943851.png" alt="image-20230113094334453"></p><p><code>spring.cloud.nacos.config.group=1005</code></p><p><img src="https://icesoda-picgo.oss-cn-beijing.aliyuncs.com/imgtest/202301130949267.png" alt="image-20230113094907253"></p></li><li><p>测试：</p><p><img src="https://icesoda-picgo.oss-cn-beijing.aliyuncs.com/imgtest/202301130952854.png" alt="image-20230113095245857"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> icesodaMall </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nacos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文章新建模板测试</title>
      <link href="/icesoda105.github.io/2023/01/12/%E6%96%87%E7%AB%A0%E6%96%B0%E5%BB%BA%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95/"/>
      <url>/icesoda105.github.io/2023/01/12/%E6%96%87%E7%AB%A0%E6%96%B0%E5%BB%BA%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> icesodaMall </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> java </tag>
            
            <tag> oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpingCloud-OpenFeign远程调用</title>
      <link href="/icesoda105.github.io/2023/01/12/SpingCloud-OpenFeign%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/"/>
      <url>/icesoda105.github.io/2023/01/12/SpingCloud-OpenFeign%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h2><blockquote><p>​Feign是一个声明式的HTTP客户端，它的目的就是让远程调用更加简单。Feign提供了HTTP请求的模板，<strong>通过编写简单的接口和插入注解</strong>，就可以定义好HTTP请求的参数、格式、地址等信息。</p><p>​Feign整合了**Ribbon(负载均衡)<strong>和</strong>Hystrix(服务熔断)**可以让我们不再需要显式地使用这两个组件。</p><p>​SpringCloudFeign在NetflixFeign的基础上扩展了对SpringMVC注解的支持，在其实现下，只需创建一个接口并用注解的方式来配置它，即可完成对服务提供方的接口绑定。简化了SpringCloudRibbon自行封装服务调用客户端的开发量。</p></blockquote><ul><li><p>引入依赖</p><p><img src="https://icesoda-picgo.oss-cn-beijing.aliyuncs.com/imgtest/202301120943546.png" alt="image-20230112094229204"></p></li><li><p>eg：member调用coupon服务</p><p><img src="https://icesoda-picgo.oss-cn-beijing.aliyuncs.com/imgtest/202301120949104.png" alt="image-20230112094857787"></p><p>ps：R代表 <strong>ResultEntity</strong></p></li></ul><h3 id="想要远程调用别的服务"><a href="#想要远程调用别的服务" class="headerlink" title="想要远程调用别的服务"></a>想要远程调用别的服务</h3><ul><li><p>引入open-feign</p></li><li><p>编写一个接口，告诉SpringCloud这个接口需要调用远程服务</p><ol><li>声明接口的每一个方法都是调用哪个远程服务的哪个请求</li></ol><p>  <img src="https://icesoda-picgo.oss-cn-beijing.aliyuncs.com/imgtest/202301120957662.png" alt="image-20230112095707363">  </p></li><li><p>开启远程调用功能 </p><p><strong>@EnableFeignClients</strong></p><p><img src="/icesoda105.github.io/upload/image-20230112101033464.png" alt="image-20230112101033464"></p></li><li><p>测试（会员服务中远程调用优惠券）</p><p>在会员服务的controller中调入优惠券远程接口</p><p><img src="https://icesoda-picgo.oss-cn-beijing.aliyuncs.com/imgtest/202301121021256.png" alt="image-20230112102151768"></p><p>远程获取结果：（被调用服务必须上线）</p><p><img src="https://icesoda-picgo.oss-cn-beijing.aliyuncs.com/imgtest/202301121038255.png" alt="image-20230112103808393"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> icesodaMall </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>seanBlog的远程仓库推送</title>
      <link href="/icesoda105.github.io/2022/12/19/seanBlog%E7%9A%84%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E6%8E%A8%E9%80%81/"/>
      <url>/icesoda105.github.io/2022/12/19/seanBlog%E7%9A%84%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E6%8E%A8%E9%80%81/</url>
      
        <content type="html"><![CDATA[<h4 id="github"><a href="#github" class="headerlink" title="github"></a>github</h4><ul><li><p>create a new repository on the command line</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;# seanblog&quot; &gt;&gt; README.md</span><br><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git branch -M main</span><br><span class="line">git remote add origin git@github.com:icesoda105/seanblog.git</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure></li><li><h3 id="push-an-existing-repository-from-the-command-line"><a href="#push-an-existing-repository-from-the-command-line" class="headerlink" title="push an existing repository from the command line"></a>push an existing repository from the command line</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:icesoda105/seanblog.git</span><br><span class="line">git branch -M main</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> icesodaMall </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>新建文章</title>
      <link href="/icesoda105.github.io/2022/12/13/%E6%96%B0%E5%BB%BA%E6%96%87%E7%AB%A0/"/>
      <url>/icesoda105.github.io/2022/12/13/%E6%96%B0%E5%BB%BA%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>图床测试</p><p><img src="https://icesoda-picgo.oss-cn-beijing.aliyuncs.com/imgtest/202301111703831.png" alt="image-20230111170338191"></p><p><img src="D:/Program%20Files/Typora/upload/image-20230111170411486.png" alt="image-20230111170411486"></p>]]></content>
      
      
      <categories>
          
          <category> icesodaMall </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nacos注册中心</title>
      <link href="/icesoda105.github.io/2022/12/12/Nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"/>
      <url>/icesoda105.github.io/2022/12/12/Nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<ul><li>将Nacos作为注册中心</li></ul><ol><li><p>给common中添加服务注册功能，Nacos依赖</p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221212165628780.png" alt="image-20221212165628780"></p></li><li><p>在应用的&#x2F;src&#x2F;main&#x2F;res&#x2F;application.properties配置文件中配置Nacos Server地址</p><ul><li><p>首先安装启动Nacos</p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221212172718855.png" alt="image-20221212172718855"></p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221212172750277.png" alt="image-20221212172750277"></p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221212174531134.png" alt="image-20221212174531134"></p></li><li><p>使用@EnableDiscoveryClient注解开启服务注册与发现功能</p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221213092900229.png" alt="image-20221213092900229"></p></li><li><p>登录nacos（账号密码默认：nacos）</p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221213093059994.png" alt="image-20221213093059994"></p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221213093151363.png" alt="image-20221213093151363"></p></li><li><p>此时是没有应用注册到</p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221213093327634.png" alt="image-20221213093327634"></p></li><li><p>在yml中添加服务名</p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221213093847698.png" alt="image-20221213093847698"></p></li><li><p>重启</p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221213094029037.png" alt="image-20221213094029037"></p></li></ul></li></ol><ul><li><p>将Nacos作为配置中心</p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221213100350157.png" alt="image-20221213100350157"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> icesodaMall </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式组件-SpringCloud-Alibaba</title>
      <link href="/icesoda105.github.io/2022/12/12/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%84%E4%BB%B6-SpringCloud-Alibaba/"/>
      <url>/icesoda105.github.io/2022/12/12/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%84%E4%BB%B6-SpringCloud-Alibaba/</url>
      
        <content type="html"><![CDATA[<h3 id="微服务-注册中心-配置中心-网关"><a href="#微服务-注册中心-配置中心-网关" class="headerlink" title="微服务-注册中心-配置中心-网关"></a>微服务-注册中心-配置中心-网关</h3><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221212145658041.png" alt="image-20221212145658041"></p><ul><li><p>注册中心：Service Discovery :</p><p>​Spring Cloud Netflix : Eureka</p></li><li><p>配置中心：Spring Cloud Config :</p><p>​Spring Cloud Netflix : Zuul</p></li><li><p>本项目使用的是SpringCloud Alibaba提供的分布式组件</p><ul><li>微服务开发的一站式解决方案，包含开发分布式应用微服务的必需组件</li><li>只需要添加一些注解和少量配置，就可以将SpringCloud Alibaba应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。</li></ul></li><li><p>SpringCloud:</p><ul><li>部分组件停止维护和更新，给开发带来不便。</li><li>部分环境搭建复杂，没有完善的可视化界面，需要大量的二次开发和定制。</li><li>配置复杂，难以上手，部分配置差别难以区分和合理应用。</li></ul></li><li><p>SpringCloud Alibaba的优势：</p><p>阿里使用过的组件经历了考验，性能强悍，设计合理，现在开源出来大家用成套的产品搭配完善的可视化界面给开发运维带来极大的便利。搭建简单，学习曲线低。</p></li><li><p>结合SpringCloud Alibaba 最终的技术搭配方案：</p><ul><li>SpringCloud Alibaba - Nacos: 注册中心（服务发现、注册）</li><li>SpringCloud Alibaba - Nacos: 配置中心（动态配置管理）</li><li>SpringCloud - Ribbon: 负载均衡</li><li>SpringCloud - Feign: 声明式HTTP客户端（调用远程服务）</li><li>SpringCloud Alibaba - Sentinel: 服务容错（限流、降级、熔断）</li><li>SpringCloud - Gateway: API网关（webflux编程模式）</li><li>SpringCloud - Sleuth: 调用链监控</li><li>SpringCloud Alibaba - Seata: 原 Fescar，即分布式事务解决方案</li></ul></li><li><p>组件</p><ul><li>Sentinel: 把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维护保护服务的稳定性。</li><li>Nacos: 一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</li><li>RocketMQ:一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订购服务。</li><li>Dubbo: Apache Dubbo(TM)是一款高性能Java RPC框架。</li><li>Seata：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。</li><li>Alibaba Cloud ACM: 一款在分布式架构环境中对应用配置进行集中管理和推送的应用配置中心产品。</li><li>Alibaba Cloud OSS: 阿里云对象存储服务（Object Storage Service,简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> icesodaMall </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>配置&amp;测试微服务基本CRUD功能</title>
      <link href="/icesoda105.github.io/2022/12/12/%E9%85%8D%E7%BD%AE-%E6%B5%8B%E8%AF%95%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%9F%BA%E6%9C%ACCRUD%E5%8A%9F%E8%83%BD/"/>
      <url>/icesoda105.github.io/2022/12/12/%E9%85%8D%E7%BD%AE-%E6%B5%8B%E8%AF%95%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%9F%BA%E6%9C%ACCRUD%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h3 id="整合Mybatis-Plus"><a href="#整合Mybatis-Plus" class="headerlink" title="整合Mybatis-Plus"></a>整合Mybatis-Plus</h3><ul><li><p>导入依赖</p></li><li><p>配置</p><ol><li><p>配置数据库</p><ul><li>导入数据库驱动(对应数据库版本)</li></ul></li><li><p>配置MyBatis-Plus</p><ul><li>使用MapperScan</li><li>告诉Mybatis-Plus，sql映射文件位置</li></ul><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221212095723955.png" alt="image-20221212095723955"></p></li></ol></li><li><p>测试向数据库添加数据</p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221212105303171.png" alt="image-20221212105303171"></p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221212105328165.png" alt="image-20221212105328165"></p></li><li><p>修改数据</p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221212110047746.png" alt="image-20221212110047746"></p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221212110118622.png" alt="image-20221212110118622"></p></li><li><p>查询数据</p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221212110718033.png" alt="image-20221212110718033"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> icesodaMall </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>逆向工程搭建&amp;使用</title>
      <link href="/icesoda105.github.io/2022/12/09/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA-%E4%BD%BF%E7%94%A8/"/>
      <url>/icesoda105.github.io/2022/12/09/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA-%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<ul><li><p>代码生成器</p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221209151432515.png" alt="image-20221209151432515"></p></li><li><p>在module中添加</p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221209151533239.png" alt="image-20221209151533239"></p></li><li><p>修改配置内容</p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221209152223447.png" alt="image-20221209152223447"></p></li><li><p>运行代码生成器</p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221209154450242.png" alt="image-20221209154450242"></p></li><li><p>逐个模块生成本地代码</p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221209160519951.png" alt="image-20221209160519951"></p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221209161742381.png" alt="image-20221209161742381"></p></li><li><p>将生成好的main文件逐个替换到微服务板块中（删除自动生产的前端代码）</p></li><li><p>创建微服务公共工具类&#x2F;bean依赖，集中管理</p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221209162620317.png" alt="image-20221209162620317"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> icesodaMall </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>后台管理系统-人人开源</title>
      <link href="/icesoda105.github.io/2022/12/09/%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E4%BA%BA%E4%BA%BA%E5%BC%80%E6%BA%90/"/>
      <url>/icesoda105.github.io/2022/12/09/%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E4%BA%BA%E4%BA%BA%E5%BC%80%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<ul><li>人人开源：renren-fast，renren-fast-vue（前后端分离）</li><li>git clone 克隆到本地后删除掉文件中的.git</li></ul><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221209110312215.png" alt="image-20221209110312215"></p><ul><li><p>在module中添加 renren-fast</p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221209110523625.png" alt="image-20221209110523625"></p></li><li><p>为后台管理系统创建数据库</p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221209110723267.png" alt="image-20221209110723267"></p></li><li><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221209111357846.png" alt="image-20221209111357846"></p></li><li><p>猫一眼配置信息</p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221209111644215.png" alt="image-20221209111644215"></p></li><li><p>修改连接信息</p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221209112016878.png" alt="image-20221209112016878"></p></li><li><p>测试运行</p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221209112139481.png" alt="image-20221209112139481"></p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221209112727420.png" alt="image-20221209112727420"></p><ul><li>前端：vscode</li><li>安装node.js : Node.js是一个基于Chrome V8 引擎的JavaScript运行环境。</li><li>NPM随同NODEJS一起安装的包管理工具（使用淘宝镜像）<ul><li>npm install(管理员身份)</li><li>npm run dev</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> icesodaMall </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库初始化</title>
      <link href="/icesoda105.github.io/2022/12/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/icesoda105.github.io/2022/12/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<ul><li><p>开发工具：PowerDesigner</p><p>![image-20221209092956800](D:&#x2F;Program Files&#x2F;Typora&#x2F;resources&#x2F;image&#x2F;image-20221209092956800.png)</p></li></ul><p>![image-20221209093217025](D:&#x2F;Program Files&#x2F;Typora&#x2F;resources&#x2F;image&#x2F;image-20221209093217025.png)</p><ul><li><p>生成数据库</p><p>![image-20221209093554327](D:&#x2F;Program Files&#x2F;Typora&#x2F;resources&#x2F;image&#x2F;image-20221209093554327.png)</p></li></ul><p>![image-20221209093628635](D:&#x2F;Program Files&#x2F;Typora&#x2F;resources&#x2F;image&#x2F;image-20221209093628635.png) </p><ul><li><p>登录数据库测试连接</p><p>![image-20221209094354309](D:&#x2F;Program Files&#x2F;Typora&#x2F;resources&#x2F;image&#x2F;image-20221209094354309.png)</p></li></ul><p>![image-20221209094455462](D:&#x2F;Program Files&#x2F;Typora&#x2F;resources&#x2F;image&#x2F;image-20221209094455462.png)</p><ul><li><p>设置虚拟机docker、mysql开机自启</p><p>![image-20221209094720539](D:&#x2F;Program Files&#x2F;Typora&#x2F;resources&#x2F;image&#x2F;image-20221209094720539.png)</p></li></ul><p>![image-20221209094835224](D:&#x2F;Program Files&#x2F;Typora&#x2F;resources&#x2F;image&#x2F;image-20221209094835224.png)</p><ul><li><p>重启</p><p>![image-20221209095230667](D:&#x2F;Program Files&#x2F;Typora&#x2F;resources&#x2F;image&#x2F;image-20221209095230667.png)</p></li><li><p>PHPstudy启动本地mysql</p></li></ul><p>![image-20221209095821503](D:&#x2F;Program Files&#x2F;Typora&#x2F;resources&#x2F;image&#x2F;image-20221209095821503.png)</p><ul><li>测试连接，password：root</li><li>创建数据库</li></ul><p>![image-20221209100400629](D:&#x2F;Program Files&#x2F;Typora&#x2F;resources&#x2F;image&#x2F;image-20221209100400629.png)</p><ul><li><p>运行sql脚本建表语句</p><p>![image-20221209101830451](D:&#x2F;Program Files&#x2F;Typora&#x2F;resources&#x2F;image&#x2F;image-20221209101830451.png)</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> icesodaMall </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>环境安装配置</title>
      <link href="/icesoda105.github.io/2022/11/15/%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
      <url>/icesoda105.github.io/2022/11/15/%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<ul><li><p>jdk版本要求1.8+</p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221115131705443.png" alt="image-20221115131705443"></p></li><li><p>Maven版本</p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221115131820927.png" alt="image-20221115131820927"></p></li><li><p>替换镜像</p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221115132153587.png" alt="image-20221115132153587"></p><p>替换为阿里云镜像</p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221115132332622.png" alt="image-20221115132332622"></p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221115132751068.png" alt="image-20221115132751068"></p></li><li><p>idea整合maven</p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221115133012521.png" alt="image-20221115133012521"></p></li><li><p>idea安装插件</p><ul><li><p>lombok 简化开发</p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221115133950708.png" alt="image-20221115133950708"></p></li><li><p>mybatisx mybatisPlus提供的快速定位到xml</p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221115134115690.png" alt="image-20221115134115690"></p></li></ul></li><li><p>前端开发 vscode 插件安装</p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221115134649040.png" alt="image-20221115134649040"></p></li><li><p>配置git</p></li><li><p>创建每一个微服务模块</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> icesodaMall </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>安装docker</title>
      <link href="/icesoda105.github.io/2022/11/11/%E5%AE%89%E8%A3%85docker/"/>
      <url>/icesoda105.github.io/2022/11/11/%E5%AE%89%E8%A3%85docker/</url>
      
        <content type="html"><![CDATA[<h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><h4 id="：虚拟化容器技术，docker基于镜像，可以秒级启动各种容器。每一种容器都是一个完整的运行环境，容器之间互相隔离。"><a href="#：虚拟化容器技术，docker基于镜像，可以秒级启动各种容器。每一种容器都是一个完整的运行环境，容器之间互相隔离。" class="headerlink" title="：虚拟化容器技术，docker基于镜像，可以秒级启动各种容器。每一种容器都是一个完整的运行环境，容器之间互相隔离。"></a>：虚拟化容器技术，docker基于镜像，可以秒级启动各种容器。每一种容器都是一个完整的运行环境，容器之间互相隔离。</h4><ul><li><p>卸载之前的docker</p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221111160409130.png" alt="image-20221111160409130"></p></li><li><p>安装依赖</p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221111160643690.png" alt="image-20221111160643690"></p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221111160703937.png" alt="image-20221111160703937"></p></li><li><p>安装地址</p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221111160828423.png" alt="image-20221111160828423"></p></li><li><p>安装docker以及 docker-cli docker的引擎、操作docker的客户端和它的容器</p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221111161337161.png" alt="image-20221111161337161"></p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221111161356534.png" alt="image-20221111161356534"></p></li><li><p>启动docker及设置开机自启</p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221111161630998.png" alt="image-20221111161630998"></p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221111161739522.png" alt="image-20221111161739522"></p></li><li><p>配置docker国内的镜像加速（阿里云）方便后续安装mysql、redis</p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221111162218713.png" alt="image-20221111162218713"></p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221111162309209.png" alt="image-20221111162309209"></p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221111162442526.png" alt="image-20221111162442526"></p></li><li><p>docker安装mysql</p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221111162756000.png" alt="image-20221111162756000"></p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221111163717724.png" alt="image-20221111163717724"></p></li><li><p>创建实例并启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3306:3306 --name mysql \</span><br><span class="line"></span><br><span class="line">-v /mydata/mysql/log:/var/log/mysql \</span><br><span class="line"></span><br><span class="line">-v /mydata/mysql/data:/var/lib/mysql \</span><br><span class="line"></span><br><span class="line">-v /mydata/mysql/conf:/etc/mysql \</span><br><span class="line"></span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root \</span><br><span class="line"></span><br><span class="line">-d mysql:5.7</span><br></pre></td></tr></table></figure><p>参数说明</p><blockquote><p>-p 3306:3306：将容器的 3306 端口映射到主机的 3306 端口</p><p>-v &#x2F;mydata&#x2F;mysql&#x2F;conf:&#x2F;etc&#x2F;mysql：将配置文件夹挂载到主机</p><p>-v &#x2F;mydata&#x2F;mysql&#x2F;log:&#x2F;var&#x2F;log&#x2F;mysql：将日志文件夹挂载到主机</p><p>-v &#x2F;mydata&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;：将配置文件夹挂载到主机</p><p>-e MYSQL_ROOT_PASSWORD&#x3D;root：初始化 root </p></blockquote></li><li><p>切换root用户</p><p>账号密码： vagrant</p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221111164331983.png" alt="image-20221111164331983"></p></li><li><p>主机测试虚拟机安装的mysql</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221111164644679.png" alt="image-20221111164644679"></p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221111164737720.png" alt="image-20221111164737720"></p><ul><li>mysql 一个完整且独立的运行环境 处于一个微型的Linux环境中</li></ul><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221111165409920.png" alt="image-20221111165409920"></p><ul><li>mysql配置文件的修改</li></ul><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221111174724965.png" alt="image-20221111174724965"></p></li><li><p>docker安装redis</p><ul><li><p>下载镜像</p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221114125704629.png" alt="image-20221114125704629"></p></li><li><p>创建实例并启动</p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221114130214450.png" alt="image-20221114130214450"></p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221114130452568.png" alt="image-20221114130452568"></p></li><li><p>默认持久化</p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221114130935287.png" alt="image-20221114130935287"></p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221114131001613.png" alt="image-20221114131001613"></p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221114131349501.png" alt="image-20221114131349501"></p></li><li><p>redis可视化客户端</p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221114131442405.png" alt="image-20221114131442405"></p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221114131650131.png" alt="image-20221114131650131"></p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221114131721883.png" alt="image-20221114131721883"></p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221114132103861.png" alt="image-20221114132103861"></p></li><li><p>redis官方文档</p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221114132423894.png" alt="image-20221114132423894"></p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221114132540825.png" alt="image-20221114132540825"></p></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows-虚拟机网络桥接</title>
      <link href="/icesoda105.github.io/2022/11/11/Windows-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A1%A5%E6%8E%A5/"/>
      <url>/icesoda105.github.io/2022/11/11/Windows-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A1%A5%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="网络地址转换-端口转发"><a href="#网络地址转换-端口转发" class="headerlink" title="网络地址转换-端口转发"></a>网络地址转换-端口转发</h3><ul><li><p>避免主机和Linux下端口映射工作的冗余,给虚拟机一个固定的ip地址，方便Windows和Linux  ping</p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221111151315046.png" alt="image-20221111151315046"></p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221111151622995.png" alt="image-20221111151622995"></p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221111153033521.png" alt="image-20221111153033521"></p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221111152152824.png" alt="image-20221111152152824"></p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221111153348804.png" alt="image-20221111153348804"></p><ul><li>互ping</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221111154043372.png" alt="image-20221111154043372"></p><p>  <img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221111154019687.png" alt="image-20221111154019687"></p><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221111154240896.png" alt="image-20221111154240896"></p>]]></content>
      
      
      <categories>
          
          <category> icesodaMall </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>icesodaMall基础环境搭建及启动</title>
      <link href="/icesoda105.github.io/2022/11/10/icesodaMall%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%90%AF%E5%8A%A8/"/>
      <url>/icesoda105.github.io/2022/11/10/icesodaMall%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%90%AF%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>​virtualBox、vagrant（D:\HashiCorp\Vagrant）</p><ul><li><p>vagrant版本 命令<br><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221111143948448.png" alt="image-20221111143948448"></p></li><li><p>vagrant初始化一个虚拟机</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221111144235470.png" alt="image-20221111144235470"></p><ul><li>whoami</li></ul><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221111144818744.png" alt="image-20221111144818744"></p><ol><li>启动Linux虚拟机——virtualBox</li><li>启动vagrant连接virtualBox（E:\vagrantMall）<ul><li>vagrant ssh（Windows环境下）</li></ul></li></ol><p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20221111144638849.png" alt="image-20221111144638849"></p>]]></content>
      
      
      <categories>
          
          <category> icesodaMall </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo新建博客</title>
      <link href="/icesoda105.github.io/2022/11/04/hexo%E6%96%B0%E5%BB%BA%E6%96%87%E7%AB%A0/"/>
      <url>/icesoda105.github.io/2022/11/04/hexo%E6%96%B0%E5%BB%BA%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>​新建文章 hexo new “文章名”</p><p>![009a0052121237ea261d5364c853cbf](D:&#x2F;Program Files&#x2F;Typora&#x2F;resources&#x2F;image&#x2F;009a0052121237ea261d5364c853cbf.jpg)</p>]]></content>
      
      
      <categories>
          
          <category> Hexo基本使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo启动</title>
      <link href="/icesoda105.github.io/2022/11/04/hexo%E5%90%AF%E5%8A%A8/"/>
      <url>/icesoda105.github.io/2022/11/04/hexo%E5%90%AF%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<p>启动：hexo g , hexo s </p><p>本地地址: <a href="http://localhost:4000/icesoda105/">http://localhost:4000/icesoda105/</a></p><p>![0ac902d998d93a7eb3cc73da75ca03a](D:&#x2F;Program Files&#x2F;Typora&#x2F;resources&#x2F;image&#x2F;0ac902d998d93a7eb3cc73da75ca03a.jpg)</p><p>![c41f354d1256e5028cbf2d095ca21c3](D:&#x2F;Program Files&#x2F;Typora&#x2F;resources&#x2F;image&#x2F;c41f354d1256e5028cbf2d095ca21c3.jpg)</p>]]></content>
      
      
      <categories>
          
          <category> Hexo基本使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python学习</title>
      <link href="/icesoda105.github.io/2022/11/03/Python%E5%AD%A6%E4%B9%A0/"/>
      <url>/icesoda105.github.io/2022/11/03/Python%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Python学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/icesoda105.github.io/2022/10/21/hello-world/"/>
      <url>/icesoda105.github.io/2022/10/21/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java基础知识</title>
      <link href="/icesoda105.github.io/2022/08/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/icesoda105.github.io/2022/08/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/740942_1470042423855_86F5A9F9F791DD7EA7C96F158F0FEA87.jpg" alt="740942_1470042423855_86F5A9F9F791DD7EA7C96F158F0FEA87"></p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul><li><p>双向队列的定义</p><p><code>Deque&lt;Character&gt; deque = new LinkedList&lt;&gt;();</code></p><p><code>ArrayDeque&lt;Character&gt; deque = new ArrayDeque&lt;&gt;();</code></p></li><li><p>单调队列的定义</p><p><code>ArrayDeque&lt;Integer&gt; deque = new ArrayDeque&lt;&gt;();</code></p></li><li><p>栈的定义</p><p><code>Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;();</code></p></li><li><p>哈希表的定义</p><p><code>HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();</code></p></li><li><p>entrySet的定义</p><p><code>Set&lt;Map.Entry&lt;Integer,Integer&gt;&gt; entrise = map.entrySet();</code></p></li><li><p>优先级队列定义大顶堆</p><p><code>PriorityQueue&lt;Map.Entry&lt;Integer,Integer&gt;&gt; queue= new PriorityQueue&lt;&gt;((o1,o2) -&gt; (o2.getValue() - o1.getValue()));</code></p></li></ul><h4 id="方法及属性"><a href="#方法及属性" class="headerlink" title="方法及属性"></a>方法及属性</h4><ol><li><p><strong>ArrayList</strong><code>import java.util.ArrayList;</code></p><p>​<code>ArrayList&lt;E&gt; objectName = new ArrayList&lt;&gt;();</code>  </p><ul><li>get();访问元素</li><li>set();     修改元素</li><li>remove();    删除元素</li></ul><p><strong>适用</strong>：</p><pre><code>        1. 频繁访问列表中的某一个元素。           2. 只需要在列表末尾进行添加和删除元素操作。</code></pre></li><li><p>LinkedList     <code>import java.util.LinkedList;</code></p><p><strong>适用</strong>：</p><ol><li>需要通过循环迭代来访问列表中的某些元素。</li><li>需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作。</li></ol></li></ol><h4 id="将字符串转为字符数组"><a href="#将字符串转为字符数组" class="headerlink" title="将字符串转为字符数组"></a>将字符串转为字符数组</h4><ul><li><code>char[] ch = s.toCharArray();</code></li></ul><h4 id="返回一个新的字符串"><a href="#返回一个新的字符串" class="headerlink" title="返回一个新的字符串"></a>返回一个新的字符串</h4><ul><li><code>return new String(ch,0,end);</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的迭代遍历</title>
      <link href="/icesoda105.github.io/2022/08/27/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86/"/>
      <url>/icesoda105.github.io/2022/08/27/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<ul><li><p>递归的实现就是：<strong>每一次递归调用都会把函数的局部变量、参数值、返回地址压入到调用栈中</strong>，然后递归返回的时候，从栈顶弹出上一次递归的各项参数（所以用栈也可以实现深度优先遍历）</p></li><li><p>前序遍历(<strong>中左右 入栈顺序 中右左</strong>)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;</span><br><span class="line">// 定义结果数组</span><br><span class="line">List&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">// 越界问题</span><br><span class="line">if (root == null) &#123;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">// 定义栈并初始化</span><br><span class="line">Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">stack.push(root);</span><br><span class="line"></span><br><span class="line">while (!stack.isEmpty()) &#123;</span><br><span class="line">// 定义新节点指向栈顶</span><br><span class="line">TreeNode node = stack.pop();</span><br><span class="line"></span><br><span class="line">result.add(node.val); // 中</span><br><span class="line">if (node.right !== null) &#123; // 右</span><br><span class="line">stack.push(node.right);</span><br><span class="line">&#125;</span><br><span class="line">if (node.left !== null) &#123; // 左</span><br><span class="line">stack.push(node.left);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>中序遍历**(左中右  入栈顺序：左右)**</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">List&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">if (root == null) &#123;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">// 定义一个用来访问的指针</span><br><span class="line">TreeNode cur = root;</span><br><span class="line">// 所指之处不为空有节点</span><br><span class="line">while (cur != null || !stack.isEmpty()) &#123;</span><br><span class="line">if (cur != null) &#123;</span><br><span class="line">stack.push(cur); // 找到对应节点入栈</span><br><span class="line">cur = cur.left; // 左 继续</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// 左节点取完了</span><br><span class="line">cur = stack.pop(); // 中</span><br><span class="line">result.add(cur.val); </span><br><span class="line">cur = cur.right; // 右</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>后序遍历 <strong>(左右中  用先序遍历左右循序再反转结果数组 中左右-&gt;中右左-&gt;左右中)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</span><br><span class="line">// 定义结果数组</span><br><span class="line">List&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">// 越界问题</span><br><span class="line">if (root == null) &#123;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">// 定义栈并初始化</span><br><span class="line">Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">stack.push(root);</span><br><span class="line"></span><br><span class="line">while (!stack.isEmpty()) &#123;</span><br><span class="line">// 定义新节点指向栈顶</span><br><span class="line">TreeNode node = stack.pop();</span><br><span class="line"></span><br><span class="line">result.add(node.val); // 中</span><br><span class="line">if (node.left !== null) &#123; // 左</span><br><span class="line">stack.push(node.left);</span><br><span class="line">&#125;</span><br><span class="line">if (node.right !== null) &#123; // 右</span><br><span class="line">stack.push(node.right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Collections.reverse(result);</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的递归遍历</title>
      <link href="/icesoda105.github.io/2022/08/27/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86/"/>
      <url>/icesoda105.github.io/2022/08/27/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<ul><li><p>递归算法的三要素：</p><ul><li>确定递归函数的参数和返回值</li><li>确定终止条件</li><li>确定单层递归的逻辑</li></ul></li><li><p>前序遍历</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;</span><br><span class="line">List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();</span><br><span class="line">preorder(root,result);</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void preorder(TreeNode root,List&lt;Integer&gt; result) &#123;</span><br><span class="line">if (root == null) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">result.add(root.val);</span><br><span class="line">preorder(root.left,result);</span><br><span class="line">preorder(root.right,result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>中序遍历</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">// 定义结果数组</span><br><span class="line">List&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">// 将头结点和结果加入递归函数</span><br><span class="line">inorder(root,result);</span><br><span class="line">// 返回值</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void inorder(TreeNode root,List&lt;Integer&gt; result) &#123;</span><br><span class="line">// 递归结束条件</span><br><span class="line">if (root == null) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">inorder(root.left,result);</span><br><span class="line">result.add(root,val);</span><br><span class="line">inorder(root.right,result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>后序遍历</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</span><br><span class="line">List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();</span><br><span class="line">postorder(root,result);</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void postorder(TreeNode root,List&lt;Integer&gt; result) &#123;</span><br><span class="line">if (root == null) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">preorder(root.left,result);</span><br><span class="line">preorder(root.right,result);</span><br><span class="line">result.add(root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="/icesoda105.github.io/2022/08/27/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/icesoda105.github.io/2022/08/27/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<ul><li><p>主要形式：<strong>满二叉树</strong>(2^k - 1)和<strong>完全二叉树</strong>(2^(k - 1))</p></li><li><p><strong>优先级队列</strong>其实是一个<strong>堆</strong>，堆就是一颗完全二叉树，同时保证父子节点的顺序关系</p></li><li><p>前面的树都是没有数值的，而<strong>二叉搜索树</strong>是有数值的，是一个有序树</p><ul><li>若它的左子树不为空，则左子树上所有的节点值均小于它根节点的值</li><li>若它的右子树不为空，同理</li><li>它的左右子树也分别为二叉排序树</li></ul></li><li><p><strong>平衡二叉搜索树</strong> AVL树 空树或左右子树高度差绝对值不超过1</p></li><li><p>二叉树存储方式：<strong>链式存储(指针)</strong>  顺序存储(数组)</p></li><li><p>父节点的下标为i 则左孩子<code>i*2+1</code> 右孩子<code>i*2+2</code></p></li><li><p>遍历方式：</p><ul><li>深度优先遍历：先往深走，遇到叶子节点再往回走<ul><li>前序遍历（递归法，迭代法）</li><li>中序遍历（递归法，迭代法）</li><li>后序遍历（递归法，迭代法）</li></ul></li><li>广度优先遍历：一层一层去遍历<ul><li>层序遍历（迭代法）</li></ul></li></ul></li><li><p>定义二叉树</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line">int val;</span><br><span class="line">TreeNode left;</span><br><span class="line">TreeNode right;</span><br><span class="line">TreeNode() &#123;&#125;</span><br><span class="line">TreeNode(int val) &#123;</span><br><span class="line">this.val = val;</span><br><span class="line">&#125;</span><br><span class="line">TreeNode(int val,TreeNode left,TreeNode right) &#123;</span><br><span class="line">this.val = val;</span><br><span class="line">this.left = left;</span><br><span class="line">this.right = right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeeCode 347.前 K 个高频元素</title>
      <link href="/icesoda105.github.io/2022/08/27/LeeCode-347-%E5%89%8D-K-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/"/>
      <url>/icesoda105.github.io/2022/08/27/LeeCode-347-%E5%89%8D-K-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素</p><p>&#x2F;&#x2F; 对频率进行排序 使用容器适配器 优先级队列</p><p>​    &#x2F;&#x2F; 优先级队列 就是一个披着队列外衣的堆 对外接口只是从队头取元素，从队尾添加元素</p><p>​    &#x2F;&#x2F; 优先级队列内部元素是自动按照元素的权值排列</p><p>​    &#x2F;&#x2F; 缺省情况下priority_queue利用max-heap（大顶堆）完成对元素的排序</p><p>​    &#x2F;&#x2F; 这个大顶堆是以vector为表现形式的complete binary tree（完全二叉树）</p><p>​    &#x2F;&#x2F; 堆是一颗完全二叉树 树中的每个节点的值都不小于或不大于其左右孩子的值</p><p>​    &#x2F;&#x2F; 如果父节点是大于等于左右孩子的就是大顶堆 反之小顶堆</p><p>​    &#x2F;&#x2F; 用小顶堆 每次将最小的元素弹出 最后积累的就是前K个最大元素</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="comment">// 存结果</span></span><br><span class="line">    <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">    <span class="comment">// 定义一个哈希表存值频率</span></span><br><span class="line">    HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 1. 统计每个数的频率</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        <span class="comment">// hash.put(c,hash.getOrDefault(c,0)+1); //若没有就是0，若有就是原有值增一。</span></span><br><span class="line">        map.put(num,map.getOrDefault(num,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// map有一个方法叫做entrySet,这方法可以将Map的键值对的映射关系作为set集合的元素存储到Set集合当中，</span></span><br><span class="line">    <span class="comment">// 而这种映射关系的类型就是Entry的类型。</span></span><br><span class="line">    <span class="comment">// 因此可以通过使用Getkey()和getvalue()两个方法得到Set中存储的键和值。</span></span><br><span class="line"></span><br><span class="line">    Set&lt;Map.Entry&lt;Integer,Integer&gt;&gt; entries = map.entrySet();</span><br><span class="line">    <span class="comment">// 2. 根据map的value值 构建一个大顶堆</span></span><br><span class="line">    PriorityQueue&lt;Map.Entry&lt;Integer,Integer&gt;&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((o1,o2) -&gt; (o2.getValue() - o1.getValue())); </span><br><span class="line">    <span class="comment">// 3. 遍历记录好数值频率的哈希表 放进大顶堆</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer,Integer&gt; entry : entries) &#123;</span><br><span class="line">        queue.offer(entry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以k为界限 获取k个最高频率的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">        result[i] = queue.poll().getKey();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 栈和队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeeCode 239. 滑动窗口最大值</title>
      <link href="/icesoda105.github.io/2022/08/27/LeeCode-239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
      <url>/icesoda105.github.io/2022/08/27/LeeCode-239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<blockquote><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回 滑动窗口中的最大值 。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// 队列一进一出维护窗口内元素 单调队列（单调递减） </span></span><br><span class="line">        <span class="comment">// 由大到小(队列元素排队，将最大值放在出口)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义一个单调队列</span></span><br><span class="line">        ArrayDeque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 存取最大值 个数为：n-k+1</span></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// i为nums下标 要在[i - k + 1,i]中选到最大值，只需要保证两点</span></span><br><span class="line">            <span class="comment">// 1. 队列头结点需要在此范围内（每个滑动窗口内） 不符合弹出</span></span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peek() &lt; i - k + <span class="number">1</span>) &#123;</span><br><span class="line">                deque.poll();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 既然是单调 就要保证每次放进去的数字要比末尾的都大  否则弹出</span></span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[i]) &#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 筛选后入队列</span></span><br><span class="line">            deque.offer(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当i增长到满足第一个滑动窗口范围的时候，每滑动一步就将队列头结点记录在res里</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">                res[index++] = nums[deque.peek()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 栈和队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeeCode 150. 逆波兰表达式求值</title>
      <link href="/icesoda105.github.io/2022/08/22/LeeCode-150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/"/>
      <url>/icesoda105.github.io/2022/08/22/LeeCode-150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<blockquote><p>根据 逆波兰表示法，求表达式的值。</p><p>有效的算符包括 +、-、*、&#x2F; 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><p>注意 两个整数之间的除法只保留整数部分。</p><p>可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">    <span class="comment">// 逆波兰表达式相当于是二叉树中的后序遍历</span></span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String s : tokens) &#123;</span><br><span class="line">        <span class="comment">// 判断字符串是否相等 </span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;+&quot;</span>.equals(s)) &#123;</span><br><span class="line">            <span class="comment">// 遇到加号，两数出栈做加法</span></span><br><span class="line">            stack.push(stack.pop() + stack.pop());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;-&quot;</span>.equals(s)) &#123;</span><br><span class="line">            <span class="comment">// 遇到减号，两数出栈做减法(因为先进后出需要逆序)</span></span><br><span class="line">            stack.push( - stack.pop() + stack.pop());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;*&quot;</span>.equals(s)) &#123;</span><br><span class="line">            <span class="comment">// 遇到乘号，两数出栈做乘法</span></span><br><span class="line">            stack.push(stack.pop() * stack.pop());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;/&quot;</span>.equals(s)) &#123;</span><br><span class="line">            <span class="comment">// 遇到除号，两数出栈做除法(先进后出逆序安排)</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp1</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp2</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            stack.push(temp2 / temp1);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 类型转换：字符串-&gt;int</span></span><br><span class="line">            stack.push(Integer.valueOf(s));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 栈和队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeeCode. 1047. 删除字符串中的所有相邻重复项</title>
      <link href="/icesoda105.github.io/2022/08/15/LeeCode-1047-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
      <url>/icesoda105.github.io/2022/08/15/LeeCode-1047-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<blockquote><p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p><p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p><p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 继续消消乐</span></span><br><span class="line">        <span class="comment">// 使用Deque作为堆栈</span></span><br><span class="line">        <span class="comment">// ArrayDeque会比LinkedList在除了删除元素这一点外会快一点</span></span><br><span class="line">        ArrayDeque&lt;Character&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++) &#123;</span><br><span class="line">            ch = s.charAt(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 空队列 或 不匹配时入栈</span></span><br><span class="line">            <span class="keyword">if</span> (deque.isEmpty() || deque.peek() != ch) &#123;</span><br><span class="line">                deque.push(ch);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 匹配时消除</span></span><br><span class="line">                deque.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">// 收集剩余元素</span></span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">            str = deque.pop() + str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用字符串直接作为栈 省去栈转为字符串的操作</span></span><br><span class="line">        <span class="comment">// 将res当做栈</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="comment">// res的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="comment">// 当top &gt;0 即栈中有字符时，当前字符如果和栈中字符相等，弹出栈顶字符</span></span><br><span class="line">            <span class="keyword">if</span> (top &gt;= <span class="number">0</span> &amp;&amp; res.charAt(top) == c) &#123;</span><br><span class="line">                res.deleteCharAt(top);</span><br><span class="line">                top--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则 将该字符入栈</span></span><br><span class="line">                res.append(c);</span><br><span class="line">                top++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双指针</span></span><br><span class="line">    <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fast &lt; s.length()) &#123;</span><br><span class="line">        <span class="comment">// 直接用fast指针覆盖slow指针的值</span></span><br><span class="line">        ch[slow] = ch[fast]; </span><br><span class="line">        <span class="comment">// 遇到前后相同值得 就跳过 slow后退一步 下次循环就可以直接覆盖掉</span></span><br><span class="line">        <span class="keyword">if</span> (slow &gt; <span class="number">0</span> &amp;&amp; ch[slow] == ch[slow - <span class="number">1</span>]) &#123;</span><br><span class="line">            slow--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            slow++;</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回一个新的字符串</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch,<span class="number">0</span>,slow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 栈和队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeeCode. 20. 有效的括号</title>
      <link href="/icesoda105.github.io/2022/08/15/LeeCode-20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
      <url>/icesoda105.github.io/2022/08/15/LeeCode-20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义一个字符型双向队列</span></span><br><span class="line">        Deque&lt;Character&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义匹配入栈规则及遍历出栈消消乐</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++) &#123;</span><br><span class="line">            <span class="comment">// 将字符串转换为字符</span></span><br><span class="line">            ch = s.charAt(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                deque.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                deque.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            deque.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果队列里有字符 且字符不匹配</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (deque.isEmpty() || deque.peek() != ch) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 如果是右括号判断是否和栈顶元素匹配 相同则消除</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                deque.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deque.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 栈和队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeeCode. 225. 用队列实现栈</title>
      <link href="/icesoda105.github.io/2022/08/15/LeeCode-225-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
      <url>/icesoda105.github.io/2022/08/15/LeeCode-225-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    <span class="comment">// 两个队列模拟一个栈</span></span><br><span class="line">    Queue&lt;Integer&gt; que1;</span><br><span class="line">    Queue&lt;Integer&gt; que2; <span class="comment">// 辅助队列 用来备份</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        que1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        que2.offer(x); <span class="comment">// 先放在辅助队列中</span></span><br><span class="line">        <span class="keyword">while</span> (!que1.isEmpty()) &#123;</span><br><span class="line">            que2.offer(que1.poll());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交换 放进que1中</span></span><br><span class="line">        Queue&lt;Integer&gt; queueTemp;</span><br><span class="line">        queueTemp = que1;</span><br><span class="line">        que1 = que2;</span><br><span class="line">        que2 = queueTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> que1.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> que1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> que1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用两个Deque实现一个栈</span></span><br><span class="line">    <span class="comment">// Deque接口继承了Queue接口</span></span><br><span class="line">    <span class="comment">// 所以Queue中的add、poll、peek等效于Deque中的addLast、pollFirst、peekFirst</span></span><br><span class="line">    Deque&lt;Integer&gt; que1;</span><br><span class="line">    Deque&lt;Integer&gt; que2; <span class="comment">// 辅助队列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        que1 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        que2 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        que1.addLast(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que1.size();</span><br><span class="line">        <span class="comment">// 将que1导入que2 但是留下最后一个值</span></span><br><span class="line">        size--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            que2.addLast(que1.peekFirst());</span><br><span class="line">            que1.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> que1.pollFirst();</span><br><span class="line">        <span class="comment">// 将que2对象的引用赋给了que1 此时que1 que2指向同一个队列</span></span><br><span class="line">        que1 = que2;</span><br><span class="line">        <span class="comment">// 如果直接操作que2 que1也会收到影响 所以为que2分配一个新的空间</span></span><br><span class="line">        que2 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> que1.peekLast();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> que1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用一个deque实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    <span class="comment">// Deque 接口继承了 Queue 接口</span></span><br><span class="line">    <span class="comment">// 所以 Queue 中的 add、poll、peek等效于 Deque 中的 addLast、pollFirst、peekFirst</span></span><br><span class="line">    Deque&lt;Integer&gt; que1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        que1 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        que1.addLast(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que1.size();</span><br><span class="line">        size--;</span><br><span class="line">        <span class="comment">// 将 que1 导入 que2 ，但留下最后一个值</span></span><br><span class="line">        <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            que1.addLast(que1.peekFirst());</span><br><span class="line">            que1.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> que1.pollFirst();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> que1.peekLast();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> que1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 栈和队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeeCode. 232. 用栈实现队列</title>
      <link href="/icesoda105.github.io/2022/08/14/LeeCode-232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
      <url>/icesoda105.github.io/2022/08/14/LeeCode-232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p><p>实现 MyQueue 类：</p><p>void push(int x) 将元素 x 推到队列的末尾<br>int pop() 从队列的开头移除并返回元素<br>int peek() 返回队列开头的元素<br>boolean empty() 如果队列为空，返回 true ；否则，返回 false<br>说明：</p><p>你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek&#x2F;pop from top, size, 和 is empty 操作是合法的。<br>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    <span class="comment">// 使用栈来模拟队列的行为，如果仅仅用一个栈，是一定不行的，所以需要两个栈一个输入栈，一个输出栈</span></span><br><span class="line">    Stack&lt;Integer&gt; stackIn;</span><br><span class="line">    Stack&lt;Integer&gt; stackOut;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        stackIn = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;(); <span class="comment">// 负责进栈</span></span><br><span class="line">        stackOut = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;(); <span class="comment">// 负责出栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        stackIn.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        dumpstackIn(); <span class="comment">// 调用辅助函数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">out</span> <span class="operator">=</span> stackOut.pop();</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        dumpstackIn(); <span class="comment">// 调用辅助函数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">out</span> <span class="operator">=</span> stackOut.peek();</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">i</span> <span class="operator">=</span> stackIn.isEmpty() &amp;&amp; stackOut.isEmpty();</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助函数</span></span><br><span class="line">    <span class="comment">// 如果出栈里为空 那么将入栈中的元素全部放出栈中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dumpstackIn</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!stackOut.isEmpty()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stackIn.isEmpty()) &#123;</span><br><span class="line">            stackOut.push(stackIn.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 栈和队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>栈和队列</title>
      <link href="/icesoda105.github.io/2022/08/14/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
      <url>/icesoda105.github.io/2022/08/14/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p><strong>队列的定义：</strong></p><ul><li><p>队列简称队，也是一种操作受限的线性表，只允许在表的一端进行插入，而在表的另一端进行删除。向队列中插入元素称为入队或进队；删除元素称为出队或离队。</p></li><li><p><strong>队头(Front)<strong>：</strong>允许删除</strong>的一端，又称为队首。</p><p><strong>队尾(Rear)<strong>：</strong>允许插入</strong>的一端。</p><p><strong>空队列：不含任何元素的空表。</strong></p></li><li><p>队列的基本操作<br>InitQueue(&amp;Q)：初始化队列，构造一个空队列Q。</p><p>QueueEmpty(Q)：判队列空，若队列Q为空返回true，否则返回false。</p><p>EnQueue(&amp;Q, x)：入队，若队列Q未满，将x加入，使之成为新的队尾。</p><p>DeQueue(&amp;Q, &amp;x)：出队，若队列Q非空，删除队头元素，并用x返回。</p><p>GetHead(Q, &amp;x)：读队头元素，若队列Q非空，则将队头元素赋值给X。</p><p>需要注意的是，队列是操作受限的线性表，所以，不是任何对线性表的操作都可以作为队列的操作。比如，不可以随便读取队列中间的某个数据。</p></li><li><p>Queue是java中实现<a href="https://so.csdn.net/so/search?q=%E9%98%9F%E5%88%97&spm=1001.2101.3001.7020">队列</a>的接口，它总共只有6个方法，我们一般只用其中3个就可以了。Queue的实现类有LinkedList和PriorityQueue。最常用的实现类是LinkedList。</p></li><li><p><strong>压入元素(添加)：add()、offer()</strong><br>相同：未超出容量，从队尾压入元素，返回压入的那个元素。<br>区别：在超出容量时，add()方法会对抛出异常，offer()返回false</p><p><strong>弹出元素(删除)：remove()、poll()</strong></p></li></ul><p>相同：容量大于0的时候，删除并返回队头被删除的那个元素。<br>  区别：在容量为0的时候，remove()会抛出异常，poll()返回false</p><p>  <strong>获取队头元素(不删除)：element()、peek()</strong><br>  相同：容量大于0的时候，都返回队头元素。但是不删除。<br>  区别：容量为0的时候，element()会抛出异常，peek()返回null。</p><ul><li><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/image-20220815085855008.png" alt="image-20220815085855008"></li></ul><blockquote><ol><li>C++中stack 是容器么？</li><li>我们使用的stack是属于哪个版本的STL？</li><li>我们使用的STL中stack是如何实现的？</li><li>stack 提供迭代器来遍历stack空间么？</li></ol></blockquote><p>​栈和队列是STL(C++标准库)里面的两个数据结构。</p><p>​C++标准库有多个版本，要知道我们使用的STL是哪个版本，才能知道对应的栈和队列的实现原理。</p><p>三个最为普遍的STL版本：</p><blockquote><ol><li>HP STL 其他版本的C++ STL，一般是以HP STL为蓝本实现出来的，HP STL是C++ STL的第一个实现版本，而且开放源代码。</li><li>P.J.Plauger STL 由P.J.Plauger参照HP STL实现出来的，被Visual C++编译器所采用，不是开源的。</li><li>SGI STL 由Silicon Graphics Computer Systems公司参照HP STL实现，被Linux的C++编译器GCC所采用，SGI STL是开源软件，源码可读性甚高。</li></ol></blockquote><p>​栈和队列也是SGI STL里面的数据结构， 知道了使用版本，才知道对应的底层实现。</p><p>​栈提供push 和 pop 等等接口，所有元素必须符合先进后出规则，所以栈不提供走访功能，也不提供迭代器(iterator)。 不像是set 或者map 提供迭代器iterator来遍历所有元素。</p><p>​<strong>栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。</strong></p><p>​所以STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器）。</p><p>​<strong>栈的内部结构，栈的底层实现可以是vector，deque，list 都是可以的， 主要就是数组和链表的底层实现。</strong></p><p>​<strong>我们常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的低层结构。</strong></p><p>​deque是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了</p><p>​<strong>SGI STL中 队列底层实现缺省情况下一样使用deque实现的。</strong></p><p>​我们也可以指定vector为栈的底层实现，初始化语句如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::stack&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt; &gt; third;  <span class="comment">// 使用vector为底层容器的栈</span></span><br></pre></td></tr></table></figure><p>​队列中先进先出的数据结构，同样不允许有遍历行为，不提供迭代器, <strong>SGI STL中队列一样是以deque为缺省情况下的底部结构。</strong></p><p>也可以指定list 为起底层实现，初始化queue的语句如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::queue&lt;<span class="type">int</span>, std::list&lt;<span class="type">int</span>&gt;&gt; third; <span class="comment">// 定义以list为底层容器的队列</span></span><br></pre></td></tr></table></figure><p>所以STL 队列也不被归类为容器，而被归类为container adapter（ 容器适配器）。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 栈和队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>十大排序算法</title>
      <link href="/icesoda105.github.io/2022/08/12/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/icesoda105.github.io/2022/08/12/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/icesoda105/PicgoWorkspace/img/1.png" alt="1"></p><p>![img](D:&#x2F;Program Files&#x2F;Typora&#x2F;resources&#x2F;image&#x2F;FM6EX4N3N{B{F@BY[41}GLS.png)</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 十大排序算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ex2. 随机排序</title>
      <link href="/icesoda105.github.io/2022/08/12/Ex2-%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%BA%8F/"/>
      <url>/icesoda105.github.io/2022/08/12/Ex2-%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Ex1. 睡眠排序</title>
      <link href="/icesoda105.github.io/2022/08/12/Ex1-%E7%9D%A1%E7%9C%A0%E6%8E%92%E5%BA%8F/"/>
      <url>/icesoda105.github.io/2022/08/12/Ex1-%E7%9D%A1%E7%9C%A0%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>十大排序-10.基数排序</title>
      <link href="/icesoda105.github.io/2022/08/12/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F-10-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
      <url>/icesoda105.github.io/2022/08/12/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F-10-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">radixSort</span> &#123;</span><br><span class="line"><span class="comment">// 基数排序法是属于稳定性的排序，基数排序法是效率高的稳定排序法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> d)</span> &#123;</span><br><span class="line"><span class="comment">// 看num从右往左第n位 相同的放进一个桶里  初始从个位开始</span></span><br><span class="line"><span class="type">int</span> <span class="variable">bit</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line"><span class="comment">// 因为每位数字一定是0~9 所以设置十个基于位数的桶</span></span><br><span class="line"><span class="type">int</span>[][] bucket = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][len];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录各桶放了多少个数字</span></span><br><span class="line"><span class="type">int</span>[] order = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line"></span><br><span class="line"><span class="comment">// d是指最大位数</span></span><br><span class="line"><span class="keyword">while</span> (bit &lt; d) &#123;</span><br><span class="line"><span class="comment">// 1. 进行第一轮 个位分桶</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line"><span class="comment">// 获取所需位数上的数值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> (num / bit) % <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 把完整数值入对应队列（底层数据结构）</span></span><br><span class="line">bucket[digit][order[digit]] = num;</span><br><span class="line"><span class="comment">// 记录对应桶里的个数</span></span><br><span class="line">order[digit]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 进行一轮排序</span></span><br><span class="line"><span class="comment">// 用于遍历原数组</span></span><br><span class="line"><span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 按照桶号遍历桶</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="comment">// 桶个数做跳出边界</span></span><br><span class="line"><span class="keyword">if</span> (order[i] != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; order[i]; j++) &#123;</span><br><span class="line">nums[k] = bucket[i][j];</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">order[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bit *= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">1234</span>,<span class="number">1005</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">234</span>&#125;;</span><br><span class="line">sort(nums,<span class="number">10000</span>);</span><br><span class="line">System.out.println(Arrays.toString(nums));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 十大排序算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>十大排序-9.桶排序</title>
      <link href="/icesoda105.github.io/2022/08/12/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F-9-%E6%A1%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/icesoda105.github.io/2022/08/12/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F-9-%E6%A1%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">binSort</span> &#123;</span><br><span class="line"><span class="comment">// 分治思想</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">float</span>[] nums)</span> &#123;</span><br><span class="line"><span class="comment">// 1. 分桶：初始化桶</span></span><br><span class="line"><span class="comment">// 由于桶元素会频繁插入，所以选择LinkedList作为桶的数据结构</span></span><br><span class="line"><span class="comment">// 桶的集合</span></span><br><span class="line">ArrayList&lt;LinkedList&lt;Float&gt;&gt; buckets = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;LinkedList&lt;Float&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">buckets.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Float&gt;()); <span class="comment">// 添加桶</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 各桶排序：数据放入桶中并完成排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">float</span> data : nums) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> getBucketIndex(data); <span class="comment">// 哪个桶</span></span><br><span class="line"><span class="comment">// 排序</span></span><br><span class="line">insertSort(buckets.get(index),data); <span class="comment">// 桶编号 数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 归位：从桶取出数据，放回nums</span></span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (LinkedList&lt;Float&gt; bucket : buckets) &#123;</span><br><span class="line"><span class="keyword">for</span> (Float data : bucket) &#123;</span><br><span class="line">nums[index++] = data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算得到输入元素应该放到哪个桶内</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getBucketIndex</span><span class="params">(<span class="type">float</span> data)</span> &#123;</span><br><span class="line"><span class="comment">// 这里仅使用浮点数的整数作为桶的索引值</span></span><br><span class="line"><span class="comment">// 实际开发具体设计</span></span><br><span class="line"><span class="keyword">return</span> (<span class="type">int</span>) data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择插入排序作为各个桶内元素排序的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(List&lt;Float&gt; bucket,<span class="type">float</span> data)</span> &#123;</span><br><span class="line">ListIterator&lt;Float&gt; it = bucket.listIterator();</span><br><span class="line"><span class="type">boolean</span> <span class="variable">insertFlag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line"><span class="keyword">if</span> (data &lt;= it.next()) &#123;</span><br><span class="line"><span class="comment">// 把迭代器的位置偏移回上一个位置</span></span><br><span class="line">it.previous();</span><br><span class="line"><span class="comment">// 把数据插入到迭代器的当前位置</span></span><br><span class="line">it.add(data);</span><br><span class="line"></span><br><span class="line">insertFlag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (insertFlag) &#123;</span><br><span class="line"><span class="comment">// 否则把数据插入到链表末端</span></span><br><span class="line">bucket.add(data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">float</span>[] nums = <span class="keyword">new</span> <span class="title class_">float</span>[] &#123;<span class="number">0.12f</span>,<span class="number">9.9f</span>,<span class="number">2.6f</span>,<span class="number">5.2f</span>,<span class="number">3.5f</span>,<span class="number">6.3f</span>,<span class="number">9.6f</span>,<span class="number">7.7f</span>,<span class="number">1.5f</span>,<span class="number">2.2f</span>&#125;;</span><br><span class="line"></span><br><span class="line">sort(nums);</span><br><span class="line">System.out.println(Arrays.toString(nums));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 十大排序算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>十大排序-8.计数排序</title>
      <link href="/icesoda105.github.io/2022/08/12/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F-8-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
      <url>/icesoda105.github.io/2022/08/12/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F-8-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">countSort</span> &#123;</span><br><span class="line"><span class="comment">// 借助足够大的辅助数组 把数字排在一个相对位置不会错的地方，最后并拢</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> min,<span class="type">int</span> max)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line"><span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希表 计数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="comment">// 将当前值与最小值的差值作为下标</span></span><br><span class="line">temp[nums[i] - min]++;</span><br><span class="line"><span class="comment">// ++值作为个数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 用于并拢</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> temp[i]; <span class="comment">// 每轮个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (cnt != <span class="number">0</span>) &#123;</span><br><span class="line">nums[index] = i + min;</span><br><span class="line">index++;</span><br><span class="line">cnt--; <span class="comment">// 个数--</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">3</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>&#125;;</span><br><span class="line">sort(nums,<span class="number">0</span>,<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">System.out.print(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 十大排序算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>十大排序-7.堆排序</title>
      <link href="/icesoda105.github.io/2022/08/12/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F-7-%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>/icesoda105.github.io/2022/08/12/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F-7-%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">heapSort</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] list)</span> &#123;</span><br><span class="line"><span class="comment">// 自底向上</span></span><br><span class="line"><span class="comment">// 将所给的无序数组构造初始堆 进而调整为大顶堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (list.length) / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="comment">// 调整堆</span></span><br><span class="line">heapAdjust(list,list.length,i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 核心排序</span></span><br><span class="line"><span class="comment">// 将最大的节点list[0]放在堆尾list[i]</span></span><br><span class="line"><span class="comment">// 然后从根节点开始调整</span></span><br><span class="line"><span class="comment">// 每次把最后一个排好的另外放好（丢掉）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> list.length - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> list[<span class="number">0</span>];</span><br><span class="line">list[<span class="number">0</span>] = list[i];</span><br><span class="line">list[i] = temp;</span><br><span class="line"><span class="comment">// 调整堆</span></span><br><span class="line">heapAdjust(list,i,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调整堆</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapAdjust</span><span class="params">(<span class="type">int</span>[] list,<span class="type">int</span> len,<span class="type">int</span> i)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>; <span class="comment">// 当前节点的左孩子</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把较小的沉下去 较大的提上来</span></span><br><span class="line"><span class="comment">// 使得最大值总是在最顶上三个里面产生</span></span><br><span class="line"><span class="keyword">while</span> (index &lt; len) &#123; <span class="comment">// 不越界</span></span><br><span class="line"><span class="comment">// index 指向左右孩子中较大的那个</span></span><br><span class="line"><span class="keyword">if</span> (index + <span class="number">1</span> &lt; len) &#123; <span class="comment">// 有右孩子</span></span><br><span class="line"><span class="comment">// 左孩子小于右孩子</span></span><br><span class="line"><span class="keyword">if</span> (list[index] &lt; list[index + <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="comment">// 让index指向左右孩子中较大的那个</span></span><br><span class="line">index = index + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较交换大孩子和根节点</span></span><br><span class="line"><span class="comment">// 大孩子大于父节点 交换</span></span><br><span class="line"><span class="keyword">if</span> (list[index] &gt; list[i]) &#123;</span><br><span class="line"><span class="comment">// 交换</span></span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> list[i];</span><br><span class="line">list[i] = list[index];</span><br><span class="line">list[index] = temp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新 下一个判断</span></span><br><span class="line">i = index;</span><br><span class="line">index = <span class="number">2</span> * i + <span class="number">1</span>; <span class="comment">// index 指向孩子的孩子 继续</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">3</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>&#125;;</span><br><span class="line">sort(nums);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">System.out.print(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 十大排序算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>十大排序-6.快速排序</title>
      <link href="/icesoda105.github.io/2022/08/12/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F-6-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>/icesoda105.github.io/2022/08/12/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F-6-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">quickSort</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start,<span class="type">int</span> end)</span> &#123;</span><br><span class="line"><span class="comment">// 终止条件</span></span><br><span class="line"><span class="keyword">if</span> (start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> start;</span><br><span class="line"><span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> end;</span><br><span class="line"><span class="comment">// 左边模拟空位</span></span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[left];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 极端两头比较</span></span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] &gt;= temp)</span><br><span class="line"><span class="comment">// 位置符合，右边继续走</span></span><br><span class="line">right--;</span><br><span class="line"><span class="comment">// 不符合则放到左空位，让出右空位</span></span><br><span class="line">nums[left] = nums[right];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] &lt;= temp)</span><br><span class="line">left++;</span><br><span class="line"><span class="comment">// 不符合则放到右空位，让出左空位</span></span><br><span class="line">nums[right] = nums[left];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// left == right 把标记点放入</span></span><br><span class="line">nums[left] = temp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归 以left/right为边界 左边是小 右边是大</span></span><br><span class="line">sort(nums,start,left - <span class="number">1</span>);</span><br><span class="line">sort(nums,left + <span class="number">1</span>,end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">9</span>&#125;;</span><br><span class="line">sort(nums,<span class="number">0</span>,nums.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">System.out.print(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 十大排序算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>十大排序-5.归并排序</title>
      <link href="/icesoda105.github.io/2022/08/12/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F-5-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/icesoda105.github.io/2022/08/12/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F-5-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mergeSort</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start,<span class="type">int</span> end)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 一直拆分</span></span><br><span class="line">sort(nums,start,mid);</span><br><span class="line">sort(nums,mid + <span class="number">1</span>,end);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并两个有序数组</span></span><br><span class="line">merge(nums,start,end);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line"><span class="comment">// 暂存有序结果</span></span><br><span class="line"><span class="type">int</span>[] tmp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line"><span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> start + (end - start) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 两个分组的首地址</span></span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> start;</span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// i初始化为start 为了与原数组位置一一对应</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= end) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[p1] &lt;= nums[p2])</span><br><span class="line">tmp[i++] = nums[p1++];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tmp[i++] = nums[p2++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有一组排完的情况</span></span><br><span class="line"><span class="keyword">while</span> (p1 &lt;= mid) &#123;</span><br><span class="line">tmp[i++] = nums[p1++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (p2 &lt;= end) &#123;</span><br><span class="line">tmp[i++] = nums[p2++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还给原数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> start; j &lt;= end; j++) &#123;</span><br><span class="line">nums[j] = tmp[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">9</span>&#125;;</span><br><span class="line">sort(nums,<span class="number">0</span>,nums.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">System.out.print(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 十大排序算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>十大排序-4.希尔排序</title>
      <link href="/icesoda105.github.io/2022/08/12/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F-4-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
      <url>/icesoda105.github.io/2022/08/12/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F-4-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">shellSort</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line"><span class="comment">// 分组 + 比较 + 排序</span></span><br><span class="line"><span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> n / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (gap &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 始终保持j位于分组后面的元素位置</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> gap; j &lt; n; j++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> j;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前后对应比较 前面大的话放到后面去</span></span><br><span class="line"><span class="keyword">while</span> ((i &gt;= gap &amp;&amp; nums[i - gap] &gt; nums[i])) &#123;</span><br><span class="line"><span class="comment">// 冒泡</span></span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">nums[i] = nums[i - gap];</span><br><span class="line">nums[i - gap] = temp;</span><br><span class="line"><span class="comment">// 保证间隔分组实现排序</span></span><br><span class="line">i -= gap;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gap = gap / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">6</span>&#125;;</span><br><span class="line">sort(nums);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">System.out.print(num + <span class="string">&quot; &quot;</span>);;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 十大排序算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>十大排序-3.插入排序</title>
      <link href="/icesoda105.github.io/2022/08/12/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F-3-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
      <url>/icesoda105.github.io/2022/08/12/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F-3-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">insertSort</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line"><span class="type">int</span> pos, cur;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123; <span class="comment">// 第一张牌 i = 0 在手里，从第二张牌开始摸</span></span><br><span class="line">pos = i - <span class="number">1</span>; <span class="comment">// pos为有序地区域元素与无序区域元素比较</span></span><br><span class="line"><span class="comment">// 用一个变量cur存放关键字</span></span><br><span class="line">cur = nums[i]; <span class="comment">// 当前摸的牌</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pos循环遍历有序元素找到小于摸到牌的元素</span></span><br><span class="line"><span class="keyword">while</span> (pos &gt;= <span class="number">0</span> &amp;&amp; cur &lt; nums[pos]) &#123; <span class="comment">// 摸到的牌小于手里的牌</span></span><br><span class="line"><span class="comment">// 手里牌右移一位</span></span><br><span class="line">nums[pos + <span class="number">1</span>] = nums[pos];</span><br><span class="line">pos--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 直到定位到，以及直接找到大牌就放到下一个位置</span></span><br><span class="line">nums[pos + <span class="number">1</span>] = cur;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">9</span>&#125;;</span><br><span class="line">sort(nums);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">System.out.print(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 十大排序算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>十大排序-2.选择排序</title>
      <link href="/icesoda105.github.io/2022/08/12/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F-2-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
      <url>/icesoda105.github.io/2022/08/12/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F-2-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>思路：找最小的元素，放在最终的位置</p><p>遍历交换更新最小值</p><p>特点：非稳定排序 O(n2)</p><p>使用：数据量少</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">selectSort</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123; <span class="comment">// 当前位置元素</span></span><br><span class="line"><span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++) &#123; <span class="comment">// 从i+1开始找最值</span></span><br><span class="line"><span class="keyword">if</span> (nums[j] &lt; nums[minIndex]) &#123;</span><br><span class="line">minIndex = j; <span class="comment">// 更新最小值下标</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">nums[i] = nums[minIndex];</span><br><span class="line">nums[minIndex] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line">sort(nums);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">System.out.print(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 十大排序算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>十大排序-1.冒泡排序</title>
      <link href="/icesoda105.github.io/2022/08/12/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F-1-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
      <url>/icesoda105.github.io/2022/08/12/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F-1-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>比较交换相邻元素</p><p><strong>temp   j &lt; n - i - 1</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">bubbleSort</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123; <span class="comment">// 控制比较轮次 一共i-1次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[j] &lt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[j];</span><br><span class="line">nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">nums[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line">sort(nums);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">System.out.print(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 十大排序算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeeCode 84. 柱状图中最大的矩形</title>
      <link href="/icesoda105.github.io/2022/08/08/LeeCode-84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/"/>
      <url>/icesoda105.github.io/2022/08/08/LeeCode-84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line"></span><br><span class="line">​    <span class="comment">// 双指针 两头开工 超出时间限制</span></span><br><span class="line"></span><br><span class="line">​    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">​    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> heights.length;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; len;i++) &#123;</span><br><span class="line"></span><br><span class="line">​      <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> i;</span><br><span class="line"></span><br><span class="line">​      <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​      <span class="keyword">for</span> (;left &gt;= <span class="number">0</span>;left--) &#123;</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">if</span> (heights[left] &lt; heights[i]) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​      <span class="keyword">for</span> (;right &lt;len;right++) &#123;</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">if</span> (heights[right] &lt; heights[i]) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​      <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> right - left - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">​      <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> heights[i];</span><br><span class="line"></span><br><span class="line">​      sum = Math.max(sum,w * h);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​    <span class="comment">// 动态规划</span></span><br><span class="line"></span><br><span class="line">​    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> heights.length;</span><br><span class="line"></span><br><span class="line">​    <span class="type">int</span>[] minLeftIndex = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line"></span><br><span class="line">​    <span class="type">int</span>[] maxRightIndex = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​    <span class="comment">// 记录左边第一个小于该柱子的下标</span></span><br><span class="line"></span><br><span class="line">​    minLeftIndex[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">​    <span class="comment">// 要考虑左边 起始就为1</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; len;i++) &#123;</span><br><span class="line"></span><br><span class="line">​      <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> i - <span class="number">1</span>; <span class="comment">// 左边</span></span><br><span class="line"></span><br><span class="line">​      <span class="comment">// 不断向右寻找</span></span><br><span class="line"></span><br><span class="line">​      <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; heights[l] &gt;= heights[i]) l = minLeftIndex[l];</span><br><span class="line"></span><br><span class="line">​      minLeftIndex[i] = l;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​    <span class="comment">// 记录右边第一个小于该柱子的下标</span></span><br><span class="line"></span><br><span class="line">​    maxRightIndex[len - <span class="number">1</span>] = len;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">2</span>;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line"></span><br><span class="line">​      <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">​      <span class="comment">// 不断向左寻找</span></span><br><span class="line"></span><br><span class="line">​      <span class="keyword">while</span> (r &lt; len &amp;&amp; heights[r] &gt;= heights[i]) r = maxRightIndex[r];</span><br><span class="line"></span><br><span class="line">​      maxRightIndex[i] = r;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​    <span class="comment">// 求和</span></span><br><span class="line"></span><br><span class="line">​    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; len;i++) &#123;</span><br><span class="line"></span><br><span class="line">​      <span class="comment">// 目标值即为对应基准上所对应的面积大小 5——10,6——6</span></span><br><span class="line"></span><br><span class="line">​      <span class="comment">// 找到俩小 中间部分一定为大 可覆盖区域</span></span><br><span class="line"></span><br><span class="line">​      <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> heights[i] * (maxRightIndex[i] - minLeftIndex[i] - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">​      result = Math.max(sum,result);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​    <span class="comment">// 单调栈 头底 从大到小</span></span><br><span class="line"></span><br><span class="line">​    Stack&lt;Integer&gt; st = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">​    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> heights.length;</span><br><span class="line"></span><br><span class="line">​    <span class="comment">// 数组扩容 在头和尾各加入一个元素</span></span><br><span class="line"></span><br><span class="line">​    <span class="type">int</span>[] newHeights = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">​    <span class="comment">// 左右测试 始末初始化</span></span><br><span class="line"></span><br><span class="line">​    </span><br><span class="line"></span><br><span class="line">​    newHeights[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">​    newHeights[newHeights.length - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​    <span class="comment">// 重新遍历分配</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">​      newHeights[i + <span class="number">1</span>] = heights[i];</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="comment">// 扩容后的数组还给原数组</span></span><br><span class="line"></span><br><span class="line">​    heights = newHeights;</span><br><span class="line"></span><br><span class="line">​    len = newHeights.length;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​    st.push(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">​    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; len;i++) &#123;</span><br><span class="line"></span><br><span class="line">​      <span class="comment">// 当前大于前一个柱子入栈</span></span><br><span class="line"></span><br><span class="line">​      <span class="keyword">if</span> (heights[i] &gt; heights[st.peek()]) &#123;</span><br><span class="line"></span><br><span class="line">​        st.push(i);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (heights[i] == heights[st.peek()]) &#123;</span><br><span class="line"></span><br><span class="line">​        st.pop();</span><br><span class="line"></span><br><span class="line">​        st.push(i);</span><br><span class="line"></span><br><span class="line">​      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">while</span> (!st.isEmpty() &amp;&amp; heights[i] &lt; heights[st.peek()]) &#123;</span><br><span class="line"></span><br><span class="line">​          <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> st.peek();</span><br><span class="line"></span><br><span class="line">​          st.pop();</span><br><span class="line"></span><br><span class="line">​          <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> st.peek();</span><br><span class="line"></span><br><span class="line">​          <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> i;</span><br><span class="line"></span><br><span class="line">​          <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> right - left - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">​          <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> heights[mid];</span><br><span class="line"></span><br><span class="line">​          result = Math.max(result,w * h);</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​        st.push(i);</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 单调栈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeeCode 42. 接雨水</title>
      <link href="/icesoda105.github.io/2022/08/08/LeeCode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
      <url>/icesoda105.github.io/2022/08/08/LeeCode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 双指针</span></span><br><span class="line"></span><br><span class="line">​    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">​    <span class="comment">// 第一个指针指向当前柱子</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; height.length;i++) &#123;</span><br><span class="line"></span><br><span class="line">​      <span class="comment">// 首尾柱子不接雨水 免测</span></span><br><span class="line"></span><br><span class="line">​      <span class="keyword">if</span> (i == <span class="number">0</span> || i == height.length - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​      <span class="comment">// 初始都为所在柱子高度 动态变化的</span></span><br><span class="line"></span><br><span class="line">​      <span class="type">int</span> <span class="variable">rHeight</span> <span class="operator">=</span> height[i]; <span class="comment">// 记录右边柱子的最高高度</span></span><br><span class="line"></span><br><span class="line">​      <span class="type">int</span> <span class="variable">lHeight</span> <span class="operator">=</span> height[i]; <span class="comment">// 记录左边柱子的最高高度</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​      <span class="comment">// 第二个指针指向前后柱子</span></span><br><span class="line"></span><br><span class="line">​      <span class="comment">// 遍历更新右柱子最高高度</span></span><br><span class="line"></span><br><span class="line">​      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> i + <span class="number">1</span>;r &lt; height.length;r++) &#123;</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">if</span> (height[r] &gt; rHeight) rHeight = height[r]; </span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​      <span class="comment">// 遍历更新左柱子最高高度</span></span><br><span class="line"></span><br><span class="line">​      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> i - <span class="number">1</span>;l &gt;= <span class="number">0</span>;l--) &#123;</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">if</span> (height[l] &gt; lHeight) lHeight = height[l];</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​      <span class="comment">// 左右柱子取最小与当前柱子相减</span></span><br><span class="line"></span><br><span class="line">​      <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> Math.min(lHeight,rHeight) - height[i];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​      <span class="comment">// 动态累加</span></span><br><span class="line"></span><br><span class="line">​      <span class="keyword">if</span> (h &gt; <span class="number">0</span>) sum += h;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​    <span class="comment">// 动态规划</span></span><br><span class="line"></span><br><span class="line">​    <span class="comment">// 当前列雨水面积：min(左边柱子的最高高度，记录右边柱子的最高高度) - 当前柱子高度。</span></span><br><span class="line"></span><br><span class="line">​    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> height.length;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">if</span> (len &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">​    <span class="type">int</span>[] maxLeft = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line"></span><br><span class="line">​    <span class="type">int</span>[] maxRight = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​    <span class="comment">// 记录每个柱子左边柱子最大高度</span></span><br><span class="line"></span><br><span class="line">​    maxLeft[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; len;i++) </span><br><span class="line"></span><br><span class="line">​      maxLeft[i] = Math.max(height[i],maxLeft[i-<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​    <span class="comment">// 记录每个柱子右边柱子最大高度</span></span><br><span class="line"></span><br><span class="line">​    maxRight[len - <span class="number">1</span>] = height[len - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">2</span>;i &gt;= <span class="number">0</span>;i--) </span><br><span class="line"></span><br><span class="line">​      maxRight[i] = Math.max(height[i],maxRight[i+<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​    <span class="comment">// 求和</span></span><br><span class="line"></span><br><span class="line">​    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; len;i++) &#123;</span><br><span class="line"></span><br><span class="line">​      <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> Math.min(maxLeft[i],maxRight[i]) - height[i];</span><br><span class="line"></span><br><span class="line">​      <span class="keyword">if</span> (count &gt; <span class="number">0</span>) sum += count;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​    <span class="comment">// 单调栈 头底从小到大</span></span><br><span class="line"></span><br><span class="line">​    <span class="comment">// 栈头元素就是凹槽底部的柱子，栈头第二个元素就是凹槽左边的柱子，而添加的元素就是凹槽右边的柱子</span></span><br><span class="line"></span><br><span class="line">​    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> height.length;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">if</span> (len &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">​    <span class="comment">// 下标入栈</span></span><br><span class="line"></span><br><span class="line">​    stack.push(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">​    <span class="comment">// 右边柱子入栈判断</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; len;i++) &#123;</span><br><span class="line"></span><br><span class="line">​       <span class="comment">// 右边柱子小则入栈</span></span><br><span class="line"></span><br><span class="line">​      <span class="keyword">if</span> (height[i] &lt; height[stack.peek()]) &#123;</span><br><span class="line"></span><br><span class="line">​        stack.push(i);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​      <span class="comment">// 高度相等 则弹出后者替换,高度差在即可</span></span><br><span class="line"></span><br><span class="line">​      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (height[i] == height[stack.peek()]) &#123;</span><br><span class="line"></span><br><span class="line">​        stack.pop();</span><br><span class="line"></span><br><span class="line">​        stack.push(i);</span><br><span class="line"></span><br><span class="line">​      </span><br><span class="line"></span><br><span class="line">​      <span class="comment">// 大于栈顶高度</span></span><br><span class="line"></span><br><span class="line">​      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; (height[i] &gt; height[stack.peek()])) &#123;</span><br><span class="line"></span><br><span class="line">​          <span class="comment">// 则中间值即为弹出的凹槽柱子</span></span><br><span class="line"></span><br><span class="line">​          <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> stack.pop();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​          <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">​            <span class="comment">// 下一栈顶即为左柱子</span></span><br><span class="line"></span><br><span class="line">​            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> stack.peek();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> Math.min(height[left],height[i]) - height[mid];</span><br><span class="line"></span><br><span class="line">​            <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> i - left - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">​            <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> h * w;</span><br><span class="line"></span><br><span class="line">​            <span class="keyword">if</span> (s &gt; <span class="number">0</span>) sum += s;</span><br><span class="line"></span><br><span class="line">​          &#125;</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​        stack.push(i);</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 单调栈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeeCode 503. 下一个更大元素 II</title>
      <link href="/icesoda105.github.io/2022/08/05/LeeCode503-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-II/"/>
      <url>/icesoda105.github.io/2022/08/05/LeeCode503-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-II/</url>
      
        <content type="html"><![CDATA[<blockquote><p>给定一个循环数组 nums （ nums[nums.length - 1] 的下一个元素是 nums[0] ），返回 nums 中每个元素的 下一个更大元素 。</p><p>数字 x 的 下一个更大的元素 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1 。</p></blockquote><p><strong>单调栈   实现循环数组 二倍数组长度</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElements(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// 循环数组 </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        Arrays.fill(result,-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始单调栈</span></span><br><span class="line">        Stack&lt;Integer&gt; st = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 下标入栈</span></span><br><span class="line">        st.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n * <span class="number">2</span> - <span class="number">1</span>;i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!st.isEmpty() &amp;&amp; nums[i % n] &gt; nums[st.peek()]) &#123;</span><br><span class="line">                result[st.peek()] = nums[i % n];</span><br><span class="line">                st.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            st.push(i % n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 单调栈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeeCode-496. 下一个更大元素 I</title>
      <link href="/icesoda105.github.io/2022/08/04/LeeCode-496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-I/"/>
      <url>/icesoda105.github.io/2022/08/04/LeeCode-496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-I/</url>
      
        <content type="html"><![CDATA[<blockquote><p>nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。</p><p>给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中nums1 是 nums2 的子集。</p><p>对于每个 0 &lt;&#x3D; i &lt; nums1.length ，找出满足 nums1[i] &#x3D;&#x3D; nums2[j] 的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 -1 。</p><p>返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的 下一个更大元素 。</p></blockquote><p><strong>单调栈  哈希表去重</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElement(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="comment">// 单调栈 从头到底 单调递增</span></span><br><span class="line">        Stack&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 需要定义一个和nums1一样大小的数组result来存放结果</span></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length];</span><br><span class="line">        <span class="comment">// 初始化为-1</span></span><br><span class="line">        Arrays.fill(res,-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 关键： 两个没有重复元素的数组 用map做映射</span></span><br><span class="line">        HashMap&lt;Integer,Integer&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把数组1的信息(下标元素，下标)录入哈希表 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums1.length;i++) &#123;</span><br><span class="line">            hashMap.put(nums1[i],i);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 栈初始下标入栈</span></span><br><span class="line">        temp.add(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数组2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums2.length;i++) &#123;</span><br><span class="line">            <span class="comment">// 小于等于栈顶下标对应的值 入栈</span></span><br><span class="line">            <span class="keyword">if</span> (nums2[i] &lt;= nums2[temp.peek()]) &#123;</span><br><span class="line">                temp.add(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 大于栈顶下标对应的值</span></span><br><span class="line">                <span class="keyword">while</span> (!temp.isEmpty() &amp;&amp; nums2[temp.peek()] &lt; nums2[i]) &#123;</span><br><span class="line">                    <span class="comment">// 判断nums1中是否有这个测试值</span></span><br><span class="line">                    <span class="keyword">if</span> (hashMap.containsKey(nums2[temp.peek()])) &#123;</span><br><span class="line">                        <span class="comment">// 获取测试值所在下标</span></span><br><span class="line">                        <span class="type">Integer</span> <span class="variable">index</span> <span class="operator">=</span> hashMap.get(nums2[temp.peek()]);</span><br><span class="line">                        <span class="comment">// 在结果数组中同步下标，记录对应目标值</span></span><br><span class="line">                        res[index] = nums2[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 弹出</span></span><br><span class="line">                    temp.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 下一个</span></span><br><span class="line">                temp.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 单调栈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeeCode 739.每日温度</title>
      <link href="/icesoda105.github.io/2022/08/03/LeeCode-739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/"/>
      <url>/icesoda105.github.io/2022/08/03/LeeCode-739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p></blockquote><p>​<strong>单调栈</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] temperatures) &#123;</span><br><span class="line">        <span class="comment">// 从栈头到栈底递增</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lens</span> <span class="operator">=</span> temperatures.length;</span><br><span class="line">        <span class="type">int</span> []res = <span class="keyword">new</span> <span class="title class_">int</span>[lens];</span><br><span class="line"></span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 将温度数组第一个元素下标入栈</span></span><br><span class="line">        stack.push(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历温度数组逐个判断入栈</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; lens;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temperatures[i] &lt;= temperatures[stack.peek()]) &#123;</span><br><span class="line">                <span class="comment">// 小于的话直接压入栈中</span></span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 积攒栈元素循环记录 栈顶一直在更新</span></span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()]) &#123;</span><br><span class="line">                    <span class="comment">// 遇到第一个大于的 取差值</span></span><br><span class="line">                    res[stack.peek()] = i - stack.peek();</span><br><span class="line">                    <span class="comment">// 记录过的弹出</span></span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 下一个值的下标入栈</span></span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 单调栈 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
